{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ratp_poll Python scripts for polling different data from RATP. Using the pgrimaud/horaires-ratp-api REST API. Based on a similar project for the Madrid intercity buses: cgupm/crtm_poll . docs docker Features RATP: Get the remaining times for the next vehicles of a line to a stop. Get the parsed remaining times for the next vehicles of a line to a stop in CSV format. Run a periodic daemon that executes one of the possible functions and stores the output a given file. Installation pip3 install git+git://github.com/cgupm/ratp_poll Docker You can use the Dockerfile to build a minimal image containing this tool and its dependencies or directly use the public image : docker run -it --rm -v \" ${ PWD } :/home/user\" -v /etc/localtime:/etc/localtime:ro --user $( id -u ) : $( id -g ) cgupm/ratp_poll Usage Once installed, this package provides a command line script that can be run as follows: ratp_poll --help ratp_poll gst [ type ] [ code ] [ station ] [ way ] Testing Tests can be run executing pytest or make test within the project's directory. License GPLv3 Author Information cgupm: c.garcia-maurino (at) alumnos.upm.es","title":"Overview"},{"location":"#ratp_poll","text":"Python scripts for polling different data from RATP. Using the pgrimaud/horaires-ratp-api REST API. Based on a similar project for the Madrid intercity buses: cgupm/crtm_poll . docs docker","title":"ratp_poll"},{"location":"#features","text":"RATP: Get the remaining times for the next vehicles of a line to a stop. Get the parsed remaining times for the next vehicles of a line to a stop in CSV format. Run a periodic daemon that executes one of the possible functions and stores the output a given file.","title":"Features"},{"location":"#installation","text":"pip3 install git+git://github.com/cgupm/ratp_poll","title":"Installation"},{"location":"#docker","text":"You can use the Dockerfile to build a minimal image containing this tool and its dependencies or directly use the public image : docker run -it --rm -v \" ${ PWD } :/home/user\" -v /etc/localtime:/etc/localtime:ro --user $( id -u ) : $( id -g ) cgupm/ratp_poll","title":"Docker"},{"location":"#usage","text":"Once installed, this package provides a command line script that can be run as follows: ratp_poll --help ratp_poll gst [ type ] [ code ] [ station ] [ way ]","title":"Usage"},{"location":"#testing","text":"Tests can be run executing pytest or make test within the project's directory.","title":"Testing"},{"location":"#license","text":"GPLv3","title":"License"},{"location":"#author-information","text":"cgupm: c.garcia-maurino (at) alumnos.upm.es","title":"Author Information"},{"location":"reference/cli/","text":"Console script for ratp_poll. load_stops_file ( stops_file ) Read file with stop codes (one by line) to array. Keyword arguments: stops_file (str): Path to the file containing the queries in CSV format. The column order is: transport_type, line_code, station_name, way . Returns: Type Description list List of tuples with the queries' parameters. Source code in ratp_poll/cli.py def load_stops_file ( stops_file ): \"\"\"Read file with stop codes (one by line) to array. Keyword arguments: stops_file (str): Path to the file containing the queries in CSV format. The column order is: `transport_type, line_code, station_name, way`. Returns: list: List of tuples with the queries' parameters. \"\"\" logger . debug ( \"stops_file: \" + str ( stops_file )) with open ( stops_file ) as f : csv_reader = reader ( f ) list_of_tuples = list ( map ( tuple , csv_reader )) logger . debug ( \"queries: \" + str ( list_of_tuples )) random . shuffle ( list_of_tuples ) return list_of_tuples","title":"cli.py"},{"location":"reference/cli/#ratp_poll.cli","text":"Console script for ratp_poll.","title":"ratp_poll.cli"},{"location":"reference/cli/#ratp_poll.cli.load_stops_file","text":"Read file with stop codes (one by line) to array. Keyword arguments: stops_file (str): Path to the file containing the queries in CSV format. The column order is: transport_type, line_code, station_name, way . Returns: Type Description list List of tuples with the queries' parameters. Source code in ratp_poll/cli.py def load_stops_file ( stops_file ): \"\"\"Read file with stop codes (one by line) to array. Keyword arguments: stops_file (str): Path to the file containing the queries in CSV format. The column order is: `transport_type, line_code, station_name, way`. Returns: list: List of tuples with the queries' parameters. \"\"\" logger . debug ( \"stops_file: \" + str ( stops_file )) with open ( stops_file ) as f : csv_reader = reader ( f ) list_of_tuples = list ( map ( tuple , csv_reader )) logger . debug ( \"queries: \" + str ( list_of_tuples )) random . shuffle ( list_of_tuples ) return list_of_tuples","title":"load_stops_file()"},{"location":"reference/daemon/daemon/","text":"exec_and_write ( func , func_args , output_file , fetch_conf ) Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Keyword arguments: func -- callable function to execute func_args -- list of arguments to pass to the executed function output_file -- path to the file were to append the results fetch_conf -- dictionary with configuration parameters for fetching the content Source code in ratp_poll/daemon/daemon.py def exec_and_write ( func , func_args , output_file , fetch_conf ): \"\"\"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Keyword arguments: func -- callable function to execute func_args -- list of arguments to pass to the executed function output_file -- path to the file were to append the results fetch_conf -- dictionary with configuration parameters for fetching the \\ content \"\"\" result , time = func ( func_args , fetch_conf ) logger . info ( \"Total iteration time: \" + str ( time ) + \"s\" ) with FileLock ( output_file + '.lock' , timeout = 60 ): path_exists = pathlib . Path ( output_file ) . exists () with open ( output_file , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) f . write ( ' \\n ' . join ( result )) logger . info ( \"Finished process at \" + str ( datetime . now ())) start_daemon ( func , func_args , output_file , interval = 60 , processes = 5 , max_conn_test = None , fetch_conf = {}) Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required interval int Number of seconds between spawns (the spawning period). 60 processes int Maximum number of simultaneously running spawned processes. 5 max_conn_test List[int] Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. list(5, 101, 5, 1) ). None fetch_conf Dict Configuration parameters for fetching the content. {} Source code in ratp_poll/daemon/daemon.py def start_daemon ( func , func_args , output_file , interval : int = 60 , processes : int = 5 , max_conn_test : List [ int ] = None , fetch_conf : Dict = {}): \"\"\"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. interval (int): Number of seconds between spawns (the spawning period). processes (int): Maximum number of simultaneously running spawned processes. max_conn_test (list): Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. `list(5, 101, 5, 1)`). fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" pool = Pool ( processes = processes ) max_conn_values = None if ( max_conn_test ): if ( len ( max_conn_test ) == 4 ): max_conn_start = max_conn_test [ 0 ] max_conn_stop = max_conn_test [ 1 ] max_conn_step = max_conn_test [ 2 ] max_conn_repeat = max_conn_test [ 3 ] max_conn_values = list ( range ( max_conn_start , max_conn_stop , max_conn_step )) random . shuffle ( max_conn_values ) max_conn_values = list ( itertools . chain . from_iterable ( itertools . repeat ( x , max_conn_repeat ) for x in max_conn_values )) logger . debug ( max_conn_values ) else : sys . exit ( 1 ) while True : if ( max_conn_test ): if ( len ( max_conn_values ) > 0 ): fetch_conf [ 'max_connections' ] = max_conn_values . pop ( 0 ) logger . info ( \"Spawned process at \" + str ( datetime . now ())) pool . apply_async ( exec_and_write , ( func , func_args , output_file , fetch_conf )) if ( max_conn_test ): if ( len ( max_conn_values ) < 1 ): while pool . _cache : time . sleep ( 1 ) logger . info ( \"Finished max_conn_test\" ) pool . close () pool . join () sys . exit ( 0 ) time . sleep ( interval )","title":"daemon.py"},{"location":"reference/daemon/daemon/#ratp_poll.daemon.daemon","text":"","title":"ratp_poll.daemon.daemon"},{"location":"reference/daemon/daemon/#ratp_poll.daemon.daemon.exec_and_write","text":"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Keyword arguments: func -- callable function to execute func_args -- list of arguments to pass to the executed function output_file -- path to the file were to append the results fetch_conf -- dictionary with configuration parameters for fetching the content Source code in ratp_poll/daemon/daemon.py def exec_and_write ( func , func_args , output_file , fetch_conf ): \"\"\"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Keyword arguments: func -- callable function to execute func_args -- list of arguments to pass to the executed function output_file -- path to the file were to append the results fetch_conf -- dictionary with configuration parameters for fetching the \\ content \"\"\" result , time = func ( func_args , fetch_conf ) logger . info ( \"Total iteration time: \" + str ( time ) + \"s\" ) with FileLock ( output_file + '.lock' , timeout = 60 ): path_exists = pathlib . Path ( output_file ) . exists () with open ( output_file , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) f . write ( ' \\n ' . join ( result )) logger . info ( \"Finished process at \" + str ( datetime . now ()))","title":"exec_and_write()"},{"location":"reference/daemon/daemon/#ratp_poll.daemon.daemon.start_daemon","text":"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required interval int Number of seconds between spawns (the spawning period). 60 processes int Maximum number of simultaneously running spawned processes. 5 max_conn_test List[int] Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. list(5, 101, 5, 1) ). None fetch_conf Dict Configuration parameters for fetching the content. {} Source code in ratp_poll/daemon/daemon.py def start_daemon ( func , func_args , output_file , interval : int = 60 , processes : int = 5 , max_conn_test : List [ int ] = None , fetch_conf : Dict = {}): \"\"\"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. interval (int): Number of seconds between spawns (the spawning period). processes (int): Maximum number of simultaneously running spawned processes. max_conn_test (list): Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. `list(5, 101, 5, 1)`). fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" pool = Pool ( processes = processes ) max_conn_values = None if ( max_conn_test ): if ( len ( max_conn_test ) == 4 ): max_conn_start = max_conn_test [ 0 ] max_conn_stop = max_conn_test [ 1 ] max_conn_step = max_conn_test [ 2 ] max_conn_repeat = max_conn_test [ 3 ] max_conn_values = list ( range ( max_conn_start , max_conn_stop , max_conn_step )) random . shuffle ( max_conn_values ) max_conn_values = list ( itertools . chain . from_iterable ( itertools . repeat ( x , max_conn_repeat ) for x in max_conn_values )) logger . debug ( max_conn_values ) else : sys . exit ( 1 ) while True : if ( max_conn_test ): if ( len ( max_conn_values ) > 0 ): fetch_conf [ 'max_connections' ] = max_conn_values . pop ( 0 ) logger . info ( \"Spawned process at \" + str ( datetime . now ())) pool . apply_async ( exec_and_write , ( func , func_args , output_file , fetch_conf )) if ( max_conn_test ): if ( len ( max_conn_values ) < 1 ): while pool . _cache : time . sleep ( 1 ) logger . info ( \"Finished max_conn_test\" ) pool . close () pool . join () sys . exit ( 0 ) time . sleep ( interval )","title":"start_daemon()"},{"location":"reference/ratp_api/stop_times/","text":"fetch ( transport_type , line_code , station_name , way , session , fetch_conf ) Fetch the remaining time for a line to a given stop with a defined way reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date,transport_type,line_code,stop_code,way,' 'resp_time,resp_status,resp_length,timeout, 'connection_error,max_connections,timeout_time' Parameters: Name Type Description Default transport_type str The transport type (metros, rers, tramways, buses or noctiliens). required line_code str The line code (e.g. '187'). required station_name str The name of the station (e.g. 'Division+Leclerc+-+Camille+Desmoulins'). required way str Way of the line ('A', 'R' or 'A+R'). required session ClientSession The aiohttp ClientSession. required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description str Response text. Source code in ratp_poll/ratp_api/stop_times.py async def fetch ( transport_type , line_code , station_name , way , session , fetch_conf ): \"\"\"Fetch the remaining time for a line to a given stop with a defined way reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date,transport_type,line_code,stop_code,way,' \\ 'resp_time,resp_status,resp_length,timeout, \\ 'connection_error,max_connections,timeout_time' Arguments: transport_type (str): The transport type (metros, rers, tramways, buses or noctiliens). line_code (str): The line code (e.g. '187'). station_name (str): The name of the station (e.g. 'Division+Leclerc+-+Camille+Desmoulins'). way (str): Way of the line ('A', 'R' or 'A+R'). session (ClientSession): The aiohttp ClientSession. fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: str: Response text. \"\"\" global counter actual_time = None resp_time = None resp_status = None resp_length = None timeout = None connection_error = None api_url = 'https://api-ratp.pierre-grimaud.fr/v4/schedules/' params = ' {transport_type} /' \\ ' {line_code} /' \\ ' {station_name} /' \\ ' {way} ' . format ( ** locals ()) url = api_url + urllib . parse . quote ( params ) actual_time = datetime . datetime . now () try : async with session . get ( url ) as response : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () resp_status = response . status resp_text = await response . text () resp_length = len ( resp_text ) timeout = False connection_error = False logger . info ( \"Response time: \" + str ( resp_time ) + \" code: \" + str ( resp_status ) + \" length: \" + str ( resp_length )) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) return resp_text except asyncio . TimeoutError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = True connection_error = False logger . warning ( \"Timeout\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) except client_exceptions . ClientConnectorError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = False connection_error = True logger . warning ( \"Connection error\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) fetch_log ( fetch_log = None , * args ) Write the passed arguments as CSV to fetch_log if set. Parameters: Name Type Description Default fetch_log str Path to the fethc log file. None *args object CSV line column values. () Source code in ratp_poll/ratp_api/stop_times.py def fetch_log ( fetch_log = None , * args ): \"\"\"Write the passed arguments as CSV to fetch_log if set. Arguments: fetch_log (str): Path to the fethc log file. *args (object): CSV line column values. \"\"\" if ( fetch_log ): csv_columns = 'actual_date,transport_type,line_code,stop_code,way,' \\ 'resp_time,resp_status,' \\ 'resp_length,timeout,connection_error,' \\ 'max_connections,timeout_time' log_csv = \",\" . join ([ str ( arg ) for arg in args ]) logger . debug ( \"CSV fetch log line: \" + log_csv ) with FileLock ( fetch_log + '.lock' , timeout = 10 ): path_exists = pathlib . Path ( fetch_log ) . exists () with open ( fetch_log , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) else : f . write ( csv_columns + ' \\n ' ) f . write ( log_csv ) get_stop_times ( query , fetch_conf ) Get the stop times for all the bus lines in a given stop. Parameters: Name Type Description Default query tuple Tuple with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description json API answer in JSON format. float: Request time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times ( query , fetch_conf ): \"\"\"Get the stop times for all the bus lines in a given stop. Arguments: query (tuple): Tuple with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: json: API answer in JSON format. float: Request time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ([( query )], fetch_conf ) try : json = json_array [ 0 ] time = total_time return json , time except IndexError : logger . error ( \"Empty answer\" ) sys . exit ( 1 ) get_stop_times_batch ( queries , fetch_conf ) Get the remaining times for a line to a given stop with a defined way of several queries. Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description (list) List containing the API answers in JSON format. (float): Total spent time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times_batch ( queries , fetch_conf ): \"\"\"Get the remaining times for a line to a given stop with a defined way of several queries. Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: (list): List containing the API answers in JSON format. (float): Total spent time in seconds. \"\"\" dt_1 = datetime . datetime . now () loop = asyncio . get_event_loop () future = asyncio . ensure_future ( run ( queries , fetch_conf )) loop . run_until_complete ( future ) dt_2 = datetime . datetime . now () json_array = list ( filter ( None , future . result ())) total_time = ( dt_2 - dt_1 ) . total_seconds () return json_array , total_time get_stop_times_batch_parsed ( queries , fetch_conf ) Get the remaining times for a line to a given stop with a defined way of several queries in CSV format. The CSV column names are: 'actual_date,transport_type,line_code, station_name,way,remaining_minutes,destination_stop' Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list Parsed API answers in CSV format. float: Total spent time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times_batch_parsed ( queries , fetch_conf ): \"\"\"Get the remaining times for a line to a given stop with a defined way of several queries in CSV format. The CSV column names are: 'actual_date,transport_type,line_code, station_name,way,remaining_minutes,destination_stop' Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: Parsed API answers in CSV format. float: Total spent time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ( queries , fetch_conf ) csv_array = [] for stop in json_array : try : split_stop = stop . split ( '{' , 1 ) except AttributeError : logger . warning ( \"Empty answer\" ) continue if ( len ( split_stop ) > 1 ): stop = '{' + split_stop [ 1 ] try : stop_json = json . loads ( stop ) except ValueError : logger . warning ( \"json error\" ) continue try : schedules = stop_json [ 'result' ][ 'schedules' ] metadata = stop_json [ '_metadata' ] for schedule in schedules : selected_fields = [ metadata [ 'date' ], metadata [ 'call' ], schedule [ 'message' ] . replace ( ' mn' , '' ), schedule [ 'destination' ], ] row = ',' . join ( selected_fields ) csv_array . append ( row ) except ( KeyError , TypeError ): logger . warning ( \"Answer without times\" ) continue except Exception as e : logger . warning ( \"Unknown error: \" + str ( e )) continue return csv_array , total_time run ( queries , fetch_conf ) Async function that generates a aiohttp ClientSession and fetches the given queries. Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list The responses. Source code in ratp_poll/ratp_api/stop_times.py async def run ( queries , fetch_conf ): \"\"\"Async function that generates a aiohttp ClientSession and fetches the given queries. Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: The responses. \"\"\" tasks = [] # Fetch all responses within one Client session, # keep connection alive for all requests. connector = TCPConnector ( limit = fetch_conf [ 'max_connections' ]) timeout = ClientTimeout ( total = fetch_conf [ 'timeout' ]) async with ClientSession ( connector = connector , timeout = timeout ) as session : for query in queries : task = asyncio . ensure_future ( fetch ( * query , session , fetch_conf )) tasks . append ( task ) responses = await asyncio . gather ( * tasks ) # you now have all response bodies in this variable return responses","title":"stop_times.py"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times","text":"","title":"ratp_poll.ratp_api.stop_times"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.fetch","text":"Fetch the remaining time for a line to a given stop with a defined way reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date,transport_type,line_code,stop_code,way,' 'resp_time,resp_status,resp_length,timeout, 'connection_error,max_connections,timeout_time' Parameters: Name Type Description Default transport_type str The transport type (metros, rers, tramways, buses or noctiliens). required line_code str The line code (e.g. '187'). required station_name str The name of the station (e.g. 'Division+Leclerc+-+Camille+Desmoulins'). required way str Way of the line ('A', 'R' or 'A+R'). required session ClientSession The aiohttp ClientSession. required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description str Response text. Source code in ratp_poll/ratp_api/stop_times.py async def fetch ( transport_type , line_code , station_name , way , session , fetch_conf ): \"\"\"Fetch the remaining time for a line to a given stop with a defined way reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date,transport_type,line_code,stop_code,way,' \\ 'resp_time,resp_status,resp_length,timeout, \\ 'connection_error,max_connections,timeout_time' Arguments: transport_type (str): The transport type (metros, rers, tramways, buses or noctiliens). line_code (str): The line code (e.g. '187'). station_name (str): The name of the station (e.g. 'Division+Leclerc+-+Camille+Desmoulins'). way (str): Way of the line ('A', 'R' or 'A+R'). session (ClientSession): The aiohttp ClientSession. fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: str: Response text. \"\"\" global counter actual_time = None resp_time = None resp_status = None resp_length = None timeout = None connection_error = None api_url = 'https://api-ratp.pierre-grimaud.fr/v4/schedules/' params = ' {transport_type} /' \\ ' {line_code} /' \\ ' {station_name} /' \\ ' {way} ' . format ( ** locals ()) url = api_url + urllib . parse . quote ( params ) actual_time = datetime . datetime . now () try : async with session . get ( url ) as response : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () resp_status = response . status resp_text = await response . text () resp_length = len ( resp_text ) timeout = False connection_error = False logger . info ( \"Response time: \" + str ( resp_time ) + \" code: \" + str ( resp_status ) + \" length: \" + str ( resp_length )) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) return resp_text except asyncio . TimeoutError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = True connection_error = False logger . warning ( \"Timeout\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) except client_exceptions . ClientConnectorError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = False connection_error = True logger . warning ( \"Connection error\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , transport_type , line_code , station_name , way , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ])","title":"fetch()"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.fetch_log","text":"Write the passed arguments as CSV to fetch_log if set. Parameters: Name Type Description Default fetch_log str Path to the fethc log file. None *args object CSV line column values. () Source code in ratp_poll/ratp_api/stop_times.py def fetch_log ( fetch_log = None , * args ): \"\"\"Write the passed arguments as CSV to fetch_log if set. Arguments: fetch_log (str): Path to the fethc log file. *args (object): CSV line column values. \"\"\" if ( fetch_log ): csv_columns = 'actual_date,transport_type,line_code,stop_code,way,' \\ 'resp_time,resp_status,' \\ 'resp_length,timeout,connection_error,' \\ 'max_connections,timeout_time' log_csv = \",\" . join ([ str ( arg ) for arg in args ]) logger . debug ( \"CSV fetch log line: \" + log_csv ) with FileLock ( fetch_log + '.lock' , timeout = 10 ): path_exists = pathlib . Path ( fetch_log ) . exists () with open ( fetch_log , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) else : f . write ( csv_columns + ' \\n ' ) f . write ( log_csv )","title":"fetch_log()"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.get_stop_times","text":"Get the stop times for all the bus lines in a given stop. Parameters: Name Type Description Default query tuple Tuple with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description json API answer in JSON format. float: Request time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times ( query , fetch_conf ): \"\"\"Get the stop times for all the bus lines in a given stop. Arguments: query (tuple): Tuple with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: json: API answer in JSON format. float: Request time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ([( query )], fetch_conf ) try : json = json_array [ 0 ] time = total_time return json , time except IndexError : logger . error ( \"Empty answer\" ) sys . exit ( 1 )","title":"get_stop_times()"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.get_stop_times_batch","text":"Get the remaining times for a line to a given stop with a defined way of several queries. Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description (list) List containing the API answers in JSON format. (float): Total spent time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times_batch ( queries , fetch_conf ): \"\"\"Get the remaining times for a line to a given stop with a defined way of several queries. Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: (list): List containing the API answers in JSON format. (float): Total spent time in seconds. \"\"\" dt_1 = datetime . datetime . now () loop = asyncio . get_event_loop () future = asyncio . ensure_future ( run ( queries , fetch_conf )) loop . run_until_complete ( future ) dt_2 = datetime . datetime . now () json_array = list ( filter ( None , future . result ())) total_time = ( dt_2 - dt_1 ) . total_seconds () return json_array , total_time","title":"get_stop_times_batch()"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.get_stop_times_batch_parsed","text":"Get the remaining times for a line to a given stop with a defined way of several queries in CSV format. The CSV column names are: 'actual_date,transport_type,line_code, station_name,way,remaining_minutes,destination_stop' Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list Parsed API answers in CSV format. float: Total spent time in seconds. Source code in ratp_poll/ratp_api/stop_times.py def get_stop_times_batch_parsed ( queries , fetch_conf ): \"\"\"Get the remaining times for a line to a given stop with a defined way of several queries in CSV format. The CSV column names are: 'actual_date,transport_type,line_code, station_name,way,remaining_minutes,destination_stop' Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: Parsed API answers in CSV format. float: Total spent time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ( queries , fetch_conf ) csv_array = [] for stop in json_array : try : split_stop = stop . split ( '{' , 1 ) except AttributeError : logger . warning ( \"Empty answer\" ) continue if ( len ( split_stop ) > 1 ): stop = '{' + split_stop [ 1 ] try : stop_json = json . loads ( stop ) except ValueError : logger . warning ( \"json error\" ) continue try : schedules = stop_json [ 'result' ][ 'schedules' ] metadata = stop_json [ '_metadata' ] for schedule in schedules : selected_fields = [ metadata [ 'date' ], metadata [ 'call' ], schedule [ 'message' ] . replace ( ' mn' , '' ), schedule [ 'destination' ], ] row = ',' . join ( selected_fields ) csv_array . append ( row ) except ( KeyError , TypeError ): logger . warning ( \"Answer without times\" ) continue except Exception as e : logger . warning ( \"Unknown error: \" + str ( e )) continue return csv_array , total_time","title":"get_stop_times_batch_parsed()"},{"location":"reference/ratp_api/stop_times/#ratp_poll.ratp_api.stop_times.run","text":"Async function that generates a aiohttp ClientSession and fetches the given queries. Parameters: Name Type Description Default queries list List of tuples with the query details (transport_type, line_code, station_name, way). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list The responses. Source code in ratp_poll/ratp_api/stop_times.py async def run ( queries , fetch_conf ): \"\"\"Async function that generates a aiohttp ClientSession and fetches the given queries. Arguments: queries (list): List of tuples with the query details (transport_type, line_code, station_name, way). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: The responses. \"\"\" tasks = [] # Fetch all responses within one Client session, # keep connection alive for all requests. connector = TCPConnector ( limit = fetch_conf [ 'max_connections' ]) timeout = ClientTimeout ( total = fetch_conf [ 'timeout' ]) async with ClientSession ( connector = connector , timeout = timeout ) as session : for query in queries : task = asyncio . ensure_future ( fetch ( * query , session , fetch_conf )) tasks . append ( task ) responses = await asyncio . gather ( * tasks ) # you now have all response bodies in this variable return responses","title":"run()"}]}